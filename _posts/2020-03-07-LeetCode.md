---
title: 2020-03-07-LeetCode
date:  	2020-03-07 14:56:36 +0800
category: Checked
tags: LeetCode
excerpt: LeetCode每日打卡，学习Java语法算法。
---

### 2020-03-07

#### 题目

请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1

示例 1：

输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
示例 2：

输入: 
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]


限制：

1 <= push_back,pop_front,max_value的总操作数 <= 10000
1 <= value <= 10^5

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 个人题解

```
import java.util.*;
class MaxQueue {

    private LinkedList<Integer> ls;
    private LinkedList<Integer> help;

    public MaxQueue() {
        ls = new LinkedList<Integer>();
        help = new LinkedList<Integer>();
    }
    
    public int max_value() {
        if(help.size()!=0){
            return help.getFirst();
        }
        else{
            return -1;
        }
    }
    
    public void push_back(int value) {
        ls.addLast(value);
        while(help.size()!=0 && help.getLast()<value){
            help.removeLast();
        }
        help.addLast(value);
    }
    
    public int pop_front() {
        if(ls.size() != 0){
            int res = ls.removeFirst();
            if(res == help.getFirst()){
                help.removeFirst();
            }
            return res;
        }else{
            return -1;
        }

    }
}

/**
 * Your MaxQueue object will be instantiated and called as such:
 * MaxQueue obj = new MaxQueue();
 * int param_1 = obj.max_value();
 * obj.push_back(value);
 * int param_3 = obj.pop_front();
 */
```

#### 总结

1. 读题：最大滑动窗口的解决题型，关键的三个操作`max_value、push_back 和 pop_front`
2. 构建双向链表，一个主链表，存放真实数据，一个辅助链表，存放最大数据
3. 最大值，读取辅助链表中头部的值
4. 压入数据，主链表直接存入，辅助链表通过从尾部开始弹出当前值能排挤出的尽可能多地较小值，再加入辅助链表
5. 弹出数据，主链表直接弹出，辅助链表通过判断当前值是否与头部的值相等(即是否为最大值)，若是则弹出辅助链表头部

### 2020-03-06

#### 题目

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

 

示例 1：

输入：target = 9
输出：[[2,3,4],[4,5]]
示例 2：

输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]


限制：

1 <= target <= 10^5

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 个人题解

```
import java.util.*;
import java.text.*;
import java.math.*;
class Solution {
    public int[][] findContinuousSequence(int target) {
        ArrayList<int[]> array = new ArrayList<>();
        // int[][] array = new int[target][target];
        int i,j,k;
        int res = 0;
        int sum = 0;
        int index = 0;
        int len =(int) Math.ceil(target/2.0);
        for(i=1;i<=len;i++){
            for(j=i;sum<target;j++){
                sum = sum + j;
                if(sum == target){
                    int[] tmp = new int[j-i+1];
                    for(k=i;k<=j;k++){
                        tmp[index++] = k;
                    }
                    array.add(tmp);
                    res++;
                    index = 0;
                }
            }
            sum = 0;
        }
        return array.toArray(new int[0][]);
    }
}
```

执行结果：

通过

显示详情

执行用时 :9 ms, 在所有 Java 提交中击败了36.45%的用户

内存消耗 :37.1 MB, 在所有 Java 提交中击败了100.00%的用户

#### 总结

1. 读题：题目要求返回一个有限长度的int二维数组，且每个int数组的长度不等。

2. 需要自定义一个准确长度的int数组

   ```
   int[] tmp = new int[j-i+1];
   ```

3. **List.toArray()用法**

   ```
   //String[] arr = list.toArray(new String[0]);
   int[][] result = array.toArray(new int[0][])
   ```

   ```
   public Object[] toArray(Object a[]) {
       if (a.length < size)
           a = (Object[])java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), size);
       System.arraycopy(elementData, 0, a, 0, size);
       if (a.length > size)
           a[size] = null;
       return a;
   }
   ```