---
title: 2020-04-02-LeetCode
date:  	2020-04-02 14:56:36 +0800
category: Checked
tags: LeetCode
excerpt: LeetCode每日打卡，学习Java语法算法。
---

### 2020-04-02

#### 题目

根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。

给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：

如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
如果死细胞周围正好有三个活细胞，则该位置死细胞复活；
根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。

示例：

输入： 
[
  [0,1,0],
  [0,0,1],
  [1,1,1],
  [0,0,0]
]
输出：
[
  [0,0,0],
  [1,0,1],
  [0,1,1],
  [0,1,0]
]


进阶：

你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。
本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/game-of-life

#### 个人题解

```
class Solution {
    public void gameOfLife(int[][] board) {
        int xlen = board.length;
        if(xlen==0){
            return;
        }
        int ylen = board[0].length;
        int[][] temp = new int[xlen][ylen];
        int x,y;
        for(x=0;x<xlen;x++){
            for(y=0;y<ylen;y++){
                temp[x][y] = board[x][y];
            }
        }
        nextCeil(board,temp,xlen,ylen);
    }

    private void nextCeil(int[][] board,int[][] temp,int xlen,int ylen){
        int x,y;
        boolean alive;
        int ceil;
        for(x=0;x<xlen;x++){
            for(y=0;y<ylen;y++){
                ceil = 0;
                alive=(temp[x][y]==1)?true:false;
                if(x-1>=0 && y-1>=0){
                    ceil=(temp[x-1][y-1]==1)?ceil+1:ceil;
                }
                if(x-1>=0){
                    ceil=(temp[x-1][y]==1)?ceil+1:ceil;
                }
                if(y-1>=0){
                    ceil=(temp[x][y-1]==1)?ceil+1:ceil;
                }
                if(x+1<xlen && y+1<ylen){
                    ceil=(temp[x+1][y+1]==1)?ceil+1:ceil;
                }
                if(x+1<xlen){
                    ceil=(temp[x+1][y]==1)?ceil+1:ceil;
                }
                if(y+1<ylen){
                    ceil=(temp[x][y+1]==1)?ceil+1:ceil;
                }
                if(x-1>=0 && y+1<ylen){
                    ceil=(temp[x-1][y+1]==1)?ceil+1:ceil;
                }
                if(x+1<xlen && y-1>=0){
                    ceil=(temp[x+1][y-1]==1)?ceil+1:ceil;
                }
                if(ceil<2 && alive){
                    board[x][y]=0;
                }
                else if(ceil>3 && alive){
                    board[x][y]=0;
                }
                else if(ceil==3 && !alive){
                    board[x][y]=1;
                }
            }
        }
    }
}
```

#### 总结

1. 读题：处理二维数组。
2. 使用浅拷贝一个临时数组，从而进行对下一个细胞数组的处理。（要注意边界问题）

### 2020-04-01

#### 题目

有效括号字符串 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「有效括号字符串」部分。

嵌套深度 depth 定义：即有效括号字符串嵌套的层数。详情参见题末「嵌套深度」部分。

给你一个「有效括号字符串」 seq，将其分成两个不相交的子序列 A 和 B，且 A 和 B 都满足有效括号字符串的定义（注意：A.length + B.length = seq.length）。

现在，你需要从中选出 任意 一组有效括号字符串 A 和 B，使 max(depth(A), depth(B)) 的可能取值最小。

返回长度为 seq.length 答案数组 answer ，选择 A 还是 B 的编码规则是：如果 seq[i] 是 A 的一部分，那么 answer[i] = 0。否则，answer[i] = 1。即便有多个满足要求的答案存在，你也只需返回 一个。

示例 1：

输入：seq = "(()())"
输出：[0,1,1,1,1,0]
示例 2：

输入：seq = "()(())()"
输出：[0,0,0,1,1,0,1,1]


提示：

1 <= text.size <= 10000


有效括号字符串：

仅由 "(" 和 ")" 构成的字符串，对于每个左括号，都能找到与之对应的右括号，反之亦然。

下述几种情况同样属于有效括号字符串：

空字符串
连接，可以记作 AB（A 与 B 连接），其中 A 和 B 都是有效括号字符串
嵌套，可以记作 (A)，其中 A 是有效括号字符串
嵌套深度：

类似地，我们可以定义任意有效括号字符串 s 的 嵌套深度 depth(S)：

s 为空时，depth("") = 0
s 为 A 与 B 连接时，depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是有效括号字符串
s 为嵌套情况，depth("(" + A + ")") = 1 + depth(A)，其中 A 是有效括号字符串
例如：""，"()()"，和 "()(()())" 都是有效括号字符串，嵌套深度分别为 0，1，2，而 ")(" 和 "(()" 都不是有效括号字符串。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings

#### 个人题解

```
class Solution {
    public int[] maxDepthAfterSplit(String seq) {
        char[] str = seq.toCharArray();
        int dep = 0;
        ArrayList<Integer> array = new ArrayList<>();
        for(char c : str){
            if(c == '('){
                array.add(dep%2);
                dep++;
            }
            if(c == ')'){
                --dep;
                array.add(dep%2);
            }
        }
        return array.stream().mapToInt(Integer::valueOf).toArray();
    }
}
```

#### 总结

1. 读题：计算括号深度。
2. 根据括号深度平均分成两组，使两组的最大深度最小。

### 2020-03-31

#### 题目

给你一个整数数组 nums，请你将该数组升序排列。

示例 1：

输入：nums = [5,2,3,1]
输出：[1,2,3,5]
示例 2：

输入：nums = [5,1,1,2,0,0]
输出：[0,0,1,1,2,5]


提示：

1 <= nums.length <= 50000
-50000 <= nums[i] <= 50000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/sort-an-array

#### 个人题解

```
import java.util.*;
class Solution {
    public int[] sortArray(int[] nums) {
        Arrays.sort(nums);
        return nums;
    }
}
```

#### 总结

1. 读题：排序问题。
2. 使用API解题，当然排序算法还有：选择排序、冒泡排序、插入排序、快速排序、归并排序、堆排序。

### 2020-03-30

#### 题目

0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

示例 1：

输入: n = 5, m = 3
输出: 3
示例 2：

输入: n = 10, m = 17
输出: 2


限制：

1 <= n <= 10^5
1 <= m <= 10^6

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof

#### 个人题解

```
class Solution {
    public int lastRemaining(int n, int m) {
        return f(0,2,n,m);
    }

    private int f(int index,int round,int n,int m){
        if(round > n){
            return index;
        }
        else{
            return f((index+m)%round,round+1,n,m);
        }
    }
}
```

#### 总结

1. 读题：约瑟夫环问题。
2. 假设剩下的一位是0，然后从第二轮开始倒推到第n轮，此时索引所落下的位置也就是存活的一位。

### 2020-03-29

#### 题目

你现在手里有一份大小为 N x N 的「地图」（网格） grid，上面的每个「区域」（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，请你找出一个海洋区域，这个海洋区域到离它最近的陆地区域的距离是最大的。

我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。

如果我们的地图上只有陆地或者海洋，请返回 -1。

示例 1：

输入：[[1,0,1],[0,0,0],[1,0,1]]
输出：2
解释： 
海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。
示例 2：

输入：[[1,0,0],[0,0,0],[0,0,0]]
输出：4
解释： 
海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。


提示：

1 <= grid.length == grid[0].length <= 100
grid[i][j] 不是 0 就是 1

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/as-far-from-land-as-possible

#### 个人题解

```
class Solution {
    public int maxDistance(int[][] grid) {
        LinkedList<Point> queue = new LinkedList<>();
        int i,j;
        int len = grid.length;
        for(i=0;i<len;i++){
            for(j=0;j<len;j++){
                if(grid[i][j] == 1){
                    queue.addLast(new Point(i,j));
                }
            }
        }
        if(queue.size() == len*len){
            return -1;
        }
        Point point = null;
        int x=0,y=0;
        while(!queue.isEmpty()){
            point = queue.removeFirst();
            x = point.x;
            y = point.y;
            if(x-1>=0 && grid[x-1][y] == 0){
                grid[x-1][y] = grid[x][y] + 1;
                queue.addLast(new Point(x-1,y));
            }
            if(x+1<len && grid[x+1][y] == 0){
                grid[x+1][y] = grid[x][y] + 1;
                queue.addLast(new Point(x+1,y));
            }
            if(y-1>=0 && grid[x][y-1] == 0){
                grid[x][y-1] = grid[x][y] + 1;
                queue.addLast(new Point(x,y-1));
            }
            if(y+1<len && grid[x][y+1] == 0){
                grid[x][y+1] = grid[x][y] + 1;
                queue.addLast(new Point(x,y+1));
            }
        }
        return grid[x][y]-1;
    }

    class Point{
        int x;
        int y;
        public Point(int x,int y){
            this.x = x;
            this.y = y;
        }
    }
}
```

#### 个人总结

1. 读题：多点广度优先搜索。

### 2020-03-28

#### 题目

给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。

例如，如果这个列表是 ["time", "me", "bell"]，我们就可以将其表示为 S = "time#bell#" 和 indexes = [0, 2, 5]。

对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 "#" 结束，来恢复我们之前的单词列表。

那么成功对给定单词列表进行编码的最小字符串长度是多少呢？

 

示例：

输入: words = ["time", "me", "bell"]
输出: 10
说明: S = "time#bell#" ， indexes = [0, 2, 5] 。


提示：

1 <= words.length <= 2000
1 <= words[i].length <= 7
每个单词都是小写字母 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/short-encoding-of-words

#### 个人题解

```
class Solution {
    public int minimumLengthEncoding(String[] words) {
        Arrays.sort(words, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o2.length()-o1.length();
            }
        });
        ArrayList<String> list = new ArrayList<>();
        int res = 0;
        boolean isContain = false;
        for(String word : words){
            isContain = false;
            for(String s : list){
                if(s.endsWith(word)){
                    isContain = true;
                    break;
                }
            }
            if(!isContain){
                list.add(word);
                res+=word.length()+1;
            }
        }
        return res;
    }
}
```

#### 总结

1. 字符串长度计数题型。
2. 需要使用`Comparator<String>`比较器将字符串进行长度倒序，然后判断字符串的尾部是否包含其他字符串。

### 2020-03-27

#### 题目

给定一副牌，每张牌上都写着一个整数。

此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：

每组都有 X 张牌。
组内所有的牌上都写着相同的整数。
仅当你可选的 X >= 2 时返回 true。

示例 1：

输入：[1,2,3,4,4,3,2,1]
输出：true
解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]
示例 2：

输入：[1,1,1,2,2,2,3,3]
输出：false
解释：没有满足要求的分组。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards

#### 个人题解

```
import java.util.*;
class Solution {
    public boolean hasGroupsSizeX(int[] deck) {
        Map<Integer,Long> map = Arrays.stream(deck).boxed().collect(Collectors.groupingBy(Function.identity(),Collectors.counting()));
        long t = 0L;
        long local;
        for(Map.Entry<Integer,Long> entry : map.entrySet()){
            local = entry.getValue();
            if(local!=t){
                if(t>local){
                    local = t;
                    t = entry.getValue();
                }
                t = gcd(local,t);
                if(t<2){
                    return false;
                }
            }
        }
        return (t>=2)?true:false;
    }

    private long gcd(long x,long y){
        return y == 0?x:gcd(y,x%y);
    }
}
```

#### 总结

1. 读题：多个值的最大公约数。

2. 使用StreamAPI将数组中各个数字的个数装入Map`Arrays.stream(deck).boxed().collect(Collectors.groupingBy(Function.identity(),Collectors.counting()));`

3. 然后对计算多个值之间的最大公约数是否符合题意。

   ```
   private long gcd(long x,long y){
   	return y == 0?x:gcd(y,x%y);
   }
   ```

### 2020-03-26

#### 题目

在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。

车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。

返回车能够在一次移动中捕获到的卒的数量。


示例 1：

输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
输出：3
解释：
在本例中，车能够捕获所有的卒。


提示：

board.length == board[i].length == 8
board[i][j] 可以是 'R'，'.'，'B' 或 'p'
只有一个格子上存在 board[i][j] == 'R'

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/available-captures-for-rook

#### 个人题解

```
class Solution {
    public int numRookCaptures(char[][] board) {
        int i,j;
        int res=0;
        for(i=0;i<8;i++){
            for(j=0;j<8;j++){
                if(board[i][j]=='R'){
                    int x=i+1,y=j;
                    while(x!=8 && board[x][y]!='B'){
                        if(board[x][y]=='p'){
                            res++;
                            break;
                        }
                        x++;
                    }
                    x=i-1;
                    while(x!=-1 && board[x][y]!='B'){
                        if(board[x][y]=='p'){
                            res++;
                            break;
                        }
                        x--;
                    }
                    x=i;
                    y=j+1;
                    while(y!=8 && board[x][y]!='B'){
                        if(board[x][y]=='p'){
                            res++;
                            break;
                        }
                        y++;
                    }
                    y=j-1;
                    while(y!=-1 && board[x][y]!='B'){
                        if(board[x][y]=='p'){
                            res++;
                            break;
                        }
                        y--;
                    }
                    return res;
                }
            }
        }
        return 0;
    }
}
```

#### 总结

1. 读题：简单深搜问题。

### 2020-03-25

#### 题目

在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。

每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。

请你返回最终形体的表面积。

 

示例 1：

输入：[[2]]
输出：10
示例 2：

输入：[[1,2],[3,4]]
输出：34
示例 3：

输入：[[1,0],[0,2]]
输出：16
示例 4：

输入：[[1,1,1],[1,0,1],[1,1,1]]
输出：32
示例 5：

输入：[[2,2,2],[2,1,2],[2,2,2]]
输出：46


提示：

1 <= N <= 50
0 <= grid[i][j] <= 50

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/surface-area-of-3d-shapes

#### 个人题解

```
import java.math.*;
class Solution {
    public int surfaceArea(int[][] grid) {
        int n = grid.length;
        int i,j;
        int res = 0;
        for(i=0;i<n;i++){
            for(j=0;j<n;j++){
                res+=surface(grid,i,j);
            }
        }
        return res;
    }
    
    private int surface(int[][] grid,int i,int j){
        if(grid[i][j]>0){
            int sum = 2+grid[i][j]*4;
            if(i>0){
                sum -= Math.min(grid[i][j],grid[i-1][j])*2;
            }
            if(j>0){
                sum -= Math.min(grid[i][j],grid[i][j-1])*2;
            }
            return sum;
        }
        return 0;
    }
}
```

#### 总结

1. 读题：数学表面积计算题。
2. 投射不好做，程序模拟的是逐个加入柱体并减去覆盖面积。

### 2020-03-24

#### 题目

一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。

注意：本题相对原题稍作改动

 

示例 1：

输入： [1,2,3,1]
输出： 4
解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。
示例 2：

输入： [2,7,9,3,1]
输出： 12
解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。
示例 3：

输入： [2,1,4,5,3,1,1,3]
输出： 12
解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/the-masseuse-lcci

#### 个人题解

```
import java.math.*;
class Solution {
    public int massage(int[] nums) {
        int len = nums.length;
        if(len == 0){
            return 0;
        }
        if(len == 1){
            return nums[0];
        }
        int[] dp = new int[len];
        dp[0] = nums[0];
        dp[1] = Math.max(dp[0],nums[1]);
        for(int i=2;i<len;i++){
            dp[i] = Math.max(nums[i]+dp[i-2],dp[i-1]);
        }
        return dp[len-1];
    }
}
```

#### 总结

1. 读题：情景模拟题。
2. 一开始用DFS模拟情况答案超时，后来用动态规划一把过。

### 2020-03-23

#### 题目

给定一个带有头结点 head 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

 

示例 1：

输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
示例 2：

输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。


提示：

给定链表的结点数介于 1 和 100 之间。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/middle-of-the-linked-list

#### 个人题解

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while(fast!=null && fast.next!=null){
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }
}
```

#### 总结

1. 读题：快慢指针找中点。

### 2020-03-22

#### 题目

给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。

返回使 A 中的每个值都是唯一的最少操作次数。

示例 1:

输入：[1,2,2]
输出：1
解释：经过一次 move 操作，数组将变为 [1, 2, 3]。
示例 2:

输入：[3,2,1,2,1,7]
输出：6
解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。
可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。
提示：

0 <= A.length <= 40000
0 <= A[i] < 40000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique

#### 个人题解

```
class Solution {
    public int minIncrementForUnique(int[] A) {
        boolean[] b = new boolean[80000];
        int move = 0;
        int tmp;
        for(int x:A){
            if(!b[x]){
                b[x] = true;
            }else{
                tmp = x;
                x++;
                while(b[x]){
                    x++;
                }
                move += x - tmp;
                b[x] = true;
            }
        }
        return move;
    }
}
```

#### 总结

1. 读题：哈希冲突的开放地址法之线性探测法。
2. 每次操作增量1，那么发生冲突的时候+1探测。

### 2020-03-21

#### 题目

有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？

如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。

你允许：

装满任意一个水壶
清空任意一个水壶
从一个水壶向另外一个水壶倒水，直到装满或者倒空
示例 1: (From the famous "Die Hard" example)

输入: x = 3, y = 5, z = 4
输出: True
示例 2:

输入: x = 2, y = 6, z = 5
输出: False

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/water-and-jug-problem

#### 个人题解

```
class Solution {
    public boolean canMeasureWater(int x, int y, int z) {
        if(z == 0 || x == z || y == z){
            return true;
        }
        if(x == 0 || y == 0 || x == y || x + y < z){
            return false;
        }
        if(y>x){
            int temp = x;
            x = y;
            y = temp;
        }
        return z%gcd(x,y)==0;
    }

    private int gcd(int x,int y){
        int t;
        while(x%y!=0){
            t = x%y;
            x = y;
            y = t;
        }
        return y;
    }
}
```

#### 总结

1. 读题：水壶问题，实质上是最大公约数问题。
2. 数学上可以将问题转化为mx + ny = z，即x与y的最大公约数能否整除z。
3. 题目还有考虑界限的情况，例如条件有：`用以上水壶中的一或两个来盛放取得的 z升 水`，那么如果x + y < z的情况是false。

### 2020-03-20

#### 题目

输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

示例 1：

输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
示例 2：

输入：arr = [0,1,2,1], k = 1
输出：[0]


限制：

0 <= k <= arr.length <= 10000
0 <= arr[i] <= 10000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof

#### 个人题解

```
import java.util.*;
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        Arrays.sort(arr);
        ArrayList<Integer> array = new ArrayList<>();
        for(int i=0;i<k;i++){
            array.add(arr[i]);
        }
        return array.stream().mapToInt(Integer::valueOf).toArray();
    }
}
```

#### 总结

1. 读题：排序问题。
2. StreamAPI练手。

### 2020-03-19

#### 题目

给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 `"Aa"` 不能当做一个回文字符串。

**注意:**
假设字符串的长度不会超过 1010。

**示例 1:**

```
输入:
"abccccdd"

输出:
7

解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```

#### 个人题解

```
class Solution {
    public int longestPalindrome(String s) {
        char[] ch = s.toCharArray();
        int[] arr = new int[52];
        for(char c : ch){
            if(c>='a'&&c<='z'){
                arr[c-'a']++;
            }
            if(c>='A'&&c<='Z'){
                arr[c-'A'+26]++;
            }
        }
        boolean odd = true;
        int i=0,res=0;
        for(char c : ch){
            if(c>='a'&&c<='z'){
                i=c-'a';
            }
            if(c>='A'&&c<='Z'){
                i=c-'A'+26;
            }
            if(arr[i]%2==0){
                res+=arr[i];
            }
            else{
                if(odd){
                    odd = false;
                    res++;
                }
                res+=arr[i]-1;
            }
            arr[i]=0;
        }
        return res;
    }
}
```

#### 总结

1. 读题：字符串处理问题。
2. 利用大小为52的整型数组记录字符的个数，构造回文串奇数个数的字符只能有一种。

### 2020-03-18

#### 题目

矩形以列表 `[x1, y1, x2, y2]` 的形式表示，其中 `(x1, y1)` 为左下角的坐标，`(x2, y2)` 是右上角的坐标。

如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。

给出两个矩形，判断它们是否重叠并返回结果。

 

**示例 1：**

```
输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
输出：true
```

**示例 2：**

```
输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
输出：false
```

 

**提示：**

1. 两个矩形 `rec1` 和 `rec2` 都以含有四个整数的列表的形式给出。
2. 矩形中的所有坐标都处于 `-10^9` 和 `10^9` 之间。
3. `x` 轴默认指向右，`y` 轴默认指向上。
4. 你可以仅考虑矩形是正放的情况。

#### 个人题解

```
class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        if(rec2[0]>=rec1[2]||rec2[1]>=rec1[3]||rec2[2]<=rec1[0]||rec2[3]<=rec1[1]){
            return false;
        }
        return true;
    }
}
```

#### 总结

1. 读题：数学几何题。
2. rec2右上角在rec1左下角的下面或左边，或者rec2左下角在rec1右上角的上面或右边的情况不重叠，否则重叠。

### 2020-03-17

#### 题目

给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。

假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。

注意：每次拼写时，chars 中的每个字母都只能用一次。

返回词汇表 words 中你掌握的所有单词的 长度之和。

 

示例 1：

输入：words = ["cat","bt","hat","tree"], chars = "atach"
输出：6
解释： 
可以形成字符串 "cat" 和 "hat"，所以答案是 3 + 3 = 6。
示例 2：

输入：words = ["hello","world","leetcode"], chars = "welldonehoneyr"
输出：10
解释：
可以形成字符串 "hello" 和 "world"，所以答案是 5 + 5 = 10。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters

#### 个人题解

```
import java.util.*;
class Solution {
    public int countCharacters(String[] words, String chars) {
        HashMap<Character,Integer> hashMap = new HashMap<Character,Integer>();
        HashMap<Character,Integer> strMap = new HashMap<Character,Integer>();
        boolean check = false;
        int res = 0;
        char[] c = chars.toCharArray();
        int clen = c.length;
        for(char tmp : c){
            if(hashMap.get(tmp)==null){
                hashMap.put(tmp,1);
            }
            else{
                hashMap.put(tmp,hashMap.get(tmp)+1);
            }
        }
        for(String str : words){
            check = true;
            char[] s = str.toCharArray();
            for(char tmp : s){
                if(strMap.get(tmp)==null){
                    if(hashMap.get(tmp)==null){
                        check=false;
                        break;
                    }
                    strMap.put(tmp,1);
                }
                else{
                    if(hashMap.get(tmp)==null || strMap.get(tmp)+1 > hashMap.get(tmp)){
                        check=false;
                        break;
                    }
                    strMap.put(tmp,strMap.get(tmp)+1);
                }
            }
            if(check){
                res += str.length();
            }
            strMap.clear();
        }
        return res;
    }
}
```

#### 总结

1. 读题：字符串处理题型。
2. 利用两个HashMap统计原字符串和比较字符串的字符个数。

### 2020-03-16

#### 题目

字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。

示例1:

 输入："aabcccccaaa"
 输出："a2b1c5a3"
示例2:

 输入："abbccd"
 输出："abbccd"
 解释："abbccd"压缩后为"a1b2c2d1"，比原字符串长度更长。
提示：

字符串长度在[0, 50000]范围内。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/compress-string-lcci

#### 个人题解

```
class Solution {
    public String compressString(String S) {
        int len = S.length();
        char[] c = S.toCharArray();
        StringBuffer buf = new StringBuffer();
        char now = '0';
        int cnt = 0;
        for(int i=0;i<len;i++){
            if(c[i] == now){
                cnt++;
            }
            else{
                if(now!='0'){
                    buf.append(now);
                    buf.append(cnt);
                }
                now = c[i];
                cnt = 1;
            }
        }
        if(now!='0'){
            buf.append(now);
            buf.append(cnt);
        }
        if(buf.length()<len){
            return buf.toString();
        }
        else{
            return S;
        }
    }
}
```

#### 总结

1. 读题：字符串处理题型。
2. `StringBuffer`在lang包，可以append数字和字符。

### 2020-03-15

#### 题目

给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)

示例 1:

[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。

示例 2:

[[0,0,0,0,0,0,0,0]]
对于上面这个给定的矩阵, 返回 0。

注意: 给定的矩阵grid 的长度和宽度都不超过 50。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/max-area-of-island

#### 个人题解

```
import java.math.*;
class Solution {
    int res = 0;
    int cnt = 0;
    boolean[][] mark = new boolean[50][50];
    public int maxAreaOfIsland(int[][] grid) {
        int x;
        int y;
        int ylen = grid.length;
        int xlen = grid[0].length;
        for(y=0;y<ylen;y++){
            for(x=0;x<xlen;x++){
                if(!mark[y][x] && grid[y][x]==1){
                    cnt = 0;
                    dfs(y,x,ylen,xlen,grid);
                    res = Math.max(res,cnt);
                }
            }
        }
        return res;
    }

    public void dfs(int y,int x,int ylen,int xlen,int[][] grid){
        cnt++;
        mark[y][x] = true;
        if(y-1 >= 0 && !mark[y-1][x] && grid[y-1][x]==1){
            dfs(y-1,x,ylen,xlen,grid);
        }
        if(x-1 >= 0 && !mark[y][x-1] && grid[y][x-1]==1){
            dfs(y,x-1,ylen,xlen,grid);
        }
        if(y+1 < ylen && !mark[y+1][x] && grid[y+1][x]==1){
            dfs(y+1,x,ylen,xlen,grid);
        }
        if(x+1 < xlen && !mark[y][x+1] && grid[y][x+1]==1){
            dfs(y,x+1,ylen,xlen,grid);
        }
    }
}
```

#### 总结

1. 读题：简单的深搜题型。

### 2020-03-14

#### 题目

给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:

可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-increasing-subsequence

#### 个人题解

```
import java.math.*;
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if(len == 0){
            return 0;
        }
        int[] dp = new int[len];
        int res = 1;
        int tmp;
        dp[0] = 1;
        for(int i=1 ;i<len;i++){
            tmp = 1;
            for(int j=0;j<i;j++){
                if(nums[i] > nums[j]){
                    tmp = Math.max(dp[j]+1,tmp);
                }
            }
            res = Math.max(tmp,res);
            dp[i]=tmp;
        }
        return res;
    }
}
```

#### 总结

1. 读题：最长上升子序列。利用动态规划的思想。使用`dp`数组记录当前值的最长上升子序列个数。
2. 用当前值遍历旧值比较大小，若比旧值大，则取旧值的`dp`+1，求出一个最长上升子序列个数存入当前值`dp`

### 2020-03-13

#### 题目

给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。

说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

示例 1:

输入: [3,2,3]
输出: [3]
示例 2:

输入: [1,1,1,3,3,2,2,2]
输出: [1,2]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/majority-element-ii

#### 总结

1. 读题：统计每个数字出现的次数。
2. 最原始的方法是使用HashMap统计，而通过学习我又了解了一种新的算法：摩尔投票法

#### 原始题解（学习StreamAPI）

```
class Solution {
    public List<Integer> majorityElement(int[] nums) {
            Map<Integer, Long> map = Arrays.stream(nums).boxed().collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));//数组流装箱，再调用collect的分组方法统计每个数字出现的次数
        int limit = nums.length / 3;
        ArrayList<Integer> res = new ArrayList<>();
        for (Map.Entry<Integer, Long> entry : map.entrySet())//遍历Map的最佳方法
            if (limit < entry.getValue())
                res.add(entry.getKey());
        return res;
    }
}
```

#### 改进题解

```
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        // 创建返回值
        List<Integer> res = new ArrayList<>();
        if (nums == null || nums.length == 0) return res;
        // 初始化两个候选人candidate，和他们的计票
        int cand1 = nums[0], count1 = 0;
        int cand2 = nums[0], count2 = 0;
        // 摩尔投票法，分为两个阶段：配对阶段和计数阶段
        // 配对阶段
        for (int num : nums) {
            // 投票
            if (cand1 == num) {
                count1++;
                continue;
            }
            if (cand2 == num) {
                count2++;
                continue;
            }
            // 第1个候选人配对
            if (count1 == 0) {
                cand1 = num;
                count1++;
                continue;
            }
            // 第2个候选人配对
            if (count2 == 0) {
                cand2 = num;
                count2++;
                continue;
            }
            count1--;
            count2--;
        }
        // 计数阶段
        // 找到了两个候选人之后，需要确定票数是否满足大于 N/3
        count1 = 0;
        count2 = 0;
        for (int num : nums) {
            if (cand1 == num) count1++;
            else if (cand2 == num) count2++;
        }
        if (count1 > nums.length / 3) res.add(cand1);
        if (count2 > nums.length / 3) res.add(cand2);

        return res;
    }
}
```

#### 反思

1. 数组大小为N，找数字出现次数大于整个数组大小的1/M，需要初始化M-1个候选人。
2. 假设数组中每一项是投票，遍历数组，将投票对应一个候选人，要是候选人中都没有得票，如果有候选人的票数为0，则将新的候选人代替且票数记为1，否则将所有候选人票数-1。
3. 将遍历后的所有候选人所得到的总票数来判断是否符合输出条件。

### 2020-03-12

#### 题目

对于字符串 S 和 T，只有在 S = T + ... + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。

返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。

示例 1：

输入：str1 = "ABCABC", str2 = "ABC"
输出："ABC"
示例 2：

输入：str1 = "ABABAB", str2 = "ABAB"
输出："AB"
示例 3：

输入：str1 = "LEET", str2 = "CODE"
输出：""


提示：

1 <= str1.length <= 1000
1 <= str2.length <= 1000
str1[i] 和 str2[i] 为大写英文字母

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/greatest-common-divisor-of-strings

#### 总结

1. 读题：字符串处理和最大公约数的题型。通过找到最小共同子串，和各自子串的个数进行求最大公约数。
2. `String.substring(beginIndex,endIndex)`拿到子串T
3. check函数进行检验当前子串T是否为两个字符串的`S = T + ... + T`形式
4. 如果通过检验，拿两个字符串的子串个数使用辗转相除法求出最大公约数

#### 改进题解

```
class Solution {
    public String gcdOfStrings(String str1, String str2) {
        if((str1+str2).equals(str2+str1)){
            int gcd = getGcd(str1.length(),str2.length());
            return str1.substring(0,gcd);
        }
        return "";
    }
    public int getGcd(int a,int b){
        int c;
        while(a % b !=0){
            c = a % b;
            a = b;
            b = c;
        }
        return b;
    }
}
```

#### 反思

1. 既然两字符串是有共同子串组成，那么符合A+B === B+A
2. 再通过两个字符串的长度求出最大公约数

### 2020-03-11

#### 题目

给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。

形式上，如果可以找出索引 i+1 < j 且满足 (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1]) 就可以将数组三等分。

示例 1：

输出：[0,2,1,-6,6,-7,9,1,2,0,1]
输出：true
解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1
示例 2：

输入：[0,2,1,-6,6,7,9,-1,2,0,1]
输出：false
示例 3：

输入：[3,3,6,5,-2,2,5,1,-9,4]
输出：true
解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4


提示：

3 <= A.length <= 50000
-10^4 <= A[i] <= 10^4

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum

#### 个人题解

```
class Solution {
    public boolean canThreePartsEqualSum(int[] A) {
        int avg;
        int len;
        int i;
        int tmp = 0;
        int cnt = 0;
        len = A.length;
        if(len<3){
            return false;
        }
        int sum = 0;
        for(i=0;i<len;i++){
            sum += A[i];
        }
        if(sum % 3==0){
            avg = sum/3;
            for(i=0;i<len;i++){
                tmp += A[i];
                if(tmp == avg && cnt < 2){
                    cnt++;
                    if(cnt == 2 && i != len-1){
                        return true;
                    }
                    tmp = 0;
                }
            }
            return false;
        }
        else{
            return false;
        }
    }
}
```

#### 总结

1. 读题：数组划分的简单题型。在一个连续的数组中砍两刀分成三部分，每部分的总和相同。
2. 先求出平均数，再对数组遍历，每遇到一个连续的数组和值为平均数时砍一刀，当砍两刀时，且第二刀后面还有值，那么返回true
3. 其他情况返回false，比如求不出三部分的整数平均数、数组长度不足（<3）分成三部分，分不出三个部分。

### 2020-03-10

#### 题目

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。

示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

注意：两结点之间的路径长度是以它们之间边的数目表示。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/diameter-of-binary-tree

#### 个人题解

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int res = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        int tmp = dfs(root);
        return res;
    }

    public int dfs(TreeNode node){
        if(node == null){
            return 0;
        }
        int leftDepth = dfs(node.left);
        int rightDepth = dfs(node.right);
        res = Math.max(leftDepth+rightDepth,res);
        return Math.max(leftDepth,rightDepth)+1;
    }

}
```

#### 总结

1. 读题：求树的深度变形题目。建议熟记模板。
2. 使用`res`全局变量比较所有节点的左子树和右子树深度之和的最大值，即树的路径最大值。

### 2020-03-09

#### 题目

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
示例 2:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock

#### 个人题解

```
import java.math.*;
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        if(len<=1){
            return 0;
        }
        int profit = 0;
        int preMin = prices[0];
        for(int i=1;i<len;i++){
            if(prices[i] > preMin){
                profit = Math.max(profit,prices[i] - preMin);
            }
            else{
                preMin = prices[i];
            }
        }
        return profit;
    }
}
```

#### 总结

1. 读题，需要找出两值，前值为较小值，后值为较大值，两值的差是最大值
2. 用`preMin`存储当前值之前的最小值

### 2020-03-08

#### 题目

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

示例 1:

输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
示例 2:

输入: coins = [2], amount = 3
输出: -1
说明:
你可以认为每种硬币的数量是无限的。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/coin-change

#### 个人题解

```
import java.math.*;
import java.util.*;
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount+1];
        Arrays.fill(dp,-1);
        dp[0] = 0;
        for(int i=1;i<=amount;i++){
            for(int j = 0;j<coins.length;j++){
                if(coins[j] > i || (dp[i]!=-1 && dp[i-coins[j]] + 1>=dp[i]) || dp[i-coins[j]] == -1){
                    continue;
                }
                else{
                    dp[i] = dp[i-coins[j]] + 1;
                }
            }
        }
        return dp[amount];
    }
}
```

#### 总结

1. 读题：取硬币，第一题感是贪心（[2,3,5] 11会出错），第二题感是DFS深度优先算法（[1,2,5] 100会超时），广度优先算法同理，那么最后使用的是动态规划算法。
2. 用dp[amount+1]数组存储每个金额时放置硬币的最小数量，初始化`Arrays.fill(dp,-1);dp[0] = 0;`，保证不能够用硬币凑成的金额的值为-1，且当目标金额为0时，输出也应该是0
3. 动态规划新值利用旧值的思想，从小见大，金额为1开始遍历，若硬币金额大于当前金额`coins[j] > i`或当前金额已被修改过且旧值加一大于新值 `(dp[i]!=-1 && dp[i-coins[j]] + 1>=dp[i])`或旧值是硬币无法凑成的值`dp[i-coins[j]] == -1`时，`Continue;`跳过；否则，利用旧值修改新值。
4. 最后读出dp[amount+1]数组中的最新（大）值即答案

### 2020-03-07

#### 题目

请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1

示例 1：

输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
示例 2：

输入: 
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]


限制：

1 <= push_back,pop_front,max_value的总操作数 <= 10000
1 <= value <= 10^5

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof

#### 个人题解

```
import java.util.*;
class MaxQueue {

    private LinkedList<Integer> ls;
    private LinkedList<Integer> help;

    public MaxQueue() {
        ls = new LinkedList<Integer>();
        help = new LinkedList<Integer>();
    }
    
    public int max_value() {
        if(help.size()!=0){
            return help.getFirst();
        }
        else{
            return -1;
        }
    }
    
    public void push_back(int value) {
        ls.addLast(value);
        while(help.size()!=0 && help.getLast()<value){
            help.removeLast();
        }
        help.addLast(value);
    }
    
    public int pop_front() {
        if(ls.size() != 0){
            int res = ls.removeFirst();
            if(res == help.getFirst()){
                help.removeFirst();
            }
            return res;
        }else{
            return -1;
        }

    }
}

/**
 * Your MaxQueue object will be instantiated and called as such:
 * MaxQueue obj = new MaxQueue();
 * int param_1 = obj.max_value();
 * obj.push_back(value);
 * int param_3 = obj.pop_front();
 */
```

#### 总结

1. 读题：最大滑动窗口的解决题型，关键的三个操作`max_value、push_back 和 pop_front`
2. 构建双向链表，一个主链表，存放真实数据，一个辅助链表，存放最大数据
3. 最大值，读取辅助链表中头部的值
4. 压入数据，主链表直接存入，辅助链表通过从尾部开始弹出当前值能排挤出的尽可能多地较小值，再加入辅助链表
5. 弹出数据，主链表直接弹出，辅助链表通过判断当前值是否与头部的值相等(即是否为最大值)，若是则弹出辅助链表头部

### 2020-03-06

#### 题目

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

 

示例 1：

输入：target = 9
输出：[[2,3,4],[4,5]]
示例 2：

输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]


限制：

1 <= target <= 10^5

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof

#### 个人题解

```
import java.util.*;
import java.text.*;
import java.math.*;
class Solution {
    public int[][] findContinuousSequence(int target) {
        ArrayList<int[]> array = new ArrayList<>();
        // int[][] array = new int[target][target];
        int i,j,k;
        int res = 0;
        int sum = 0;
        int index = 0;
        int len =(int) Math.ceil(target/2.0);
        for(i=1;i<=len;i++){
            for(j=i;sum<target;j++){
                sum = sum + j;
                if(sum == target){
                    int[] tmp = new int[j-i+1];
                    for(k=i;k<=j;k++){
                        tmp[index++] = k;
                    }
                    array.add(tmp);
                    res++;
                    index = 0;
                }
            }
            sum = 0;
        }
        return array.toArray(new int[0][]);
    }
}
```

#### 总结

1. 读题：题目要求返回一个有限长度的int二维数组，且每个int数组的长度不等。

2. 需要自定义一个准确长度的int数组

   ```
   int[] tmp = new int[j-i+1];
   ```

3. **List.toArray()用法**

   ```
   //String[] arr = list.toArray(new String[0]);
   int[][] result = array.toArray(new int[0][])
   ```

   ```
   public Object[] toArray(Object a[]) {
       if (a.length < size)
           a = (Object[])java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), size);
       System.arraycopy(elementData, 0, a, 0, size);
       if (a.length > size)
           a[size] = null;
       return a;
   }
   ```

